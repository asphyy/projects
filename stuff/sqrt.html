<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <style>
        p {
            padding: none;
        }

        .additions {
            position: absolute;
            width: 50%;
        }
    </style>
    <input class='x' placeholder='Number (variable x)'><br>
    <input class='iterations' placeholder='# of iterations'><br>
    <input class='decimals' placeholder='# of decimals in x to account for'> (defaults to 10)<br>
    <button onclick='solve()'>solve</button><br>
    <p class='res'></p><br>
    <br>
    Code example:
    <pre><code>
let x = x*10;                                                  //multiply by 10 to handle decimals.*
let iterations = 5;                                            //higher numbers need more iterations, although 20 should be more than enough for any number
let nps = nearestPerfectSquare(x).squareRoot;                  //this would probably be done by looking through a pre-made table of whole numbers squared
let a = (x - nps*nps)/nps;                                     //initial guess of <i>a</i> - could definitely be improved
let xp1 = x % 1;                                               //save a bit of processing time by pre-calculating unchanging variables
let x2 = x * 2
let sqrtTen = 3.162277660168379331998893...
for (i = 1; i < iterations; i++){                              //start at <i>i</i> = 1 instead of 0 because final iteration still counts as 1
    a = ((x2 / ((a * 0.5) + (xp1 / a)))+a) * 0.5               //averages 2*(guess of square root of <i>x</i> with new guess of <i>a</i>) and the last value of <i>a</i>
}                                                              //(this is basically the Newton-Raphson method with a different way of finding the new a)
let sqrt = -((a * 0.5) + (xp1 / a))/sqrtTen                    //final iteration (returned values can be negative or positive)

    </code></pre><br>
    <span class='additions'>
        *Addition 1:<br>
        multiply by 10 to handle decimals because it does a bit of rounding and is innacurate for decimals as
        a result. If it's multiplied by 10, then you have to divide the square root by sqrt(10) in the final iteration
        to counter this. For handling hundreths places, multiply by 100 and divide by sqrt(100) at the end and so on.
        Keep
        in mind the denominator can be a pre-calculated constant. Note that the more decimals you account for, the
        smaller
        the numbers have to be as if you account for 20 decimals you're multiplying by 1e20 and so higher numbers can be
        rounded
        to Infinity by computers.<br>
        <br>
        **Addition 2:<br>
        It's slightly innacurate (by at most 1e-9 but usually aroud 1e-16) for the square roots of certain numbers.
        There's also
        no discernable pattern in which numbers it's innacurate for and increasing the amount of iterations doesn't
        help.
        Increasing the number of decimals handleable in Addition 1 makes it much more accurate for all numbers but can
        have an
        effect on execution time and can limit the size of numbers.<br>
        <br>
        ***Addition 3:<br>
        In <u>some</u> cases, it's faster than the browser's Math.sqrt() when running both only once, although when
        running both 10 million times Math.sqrt() is around 100 times faster.<br>
        <br>
        ****Addition 4:<br>
        This is VERY similar to a method of approximating square roots by repeatedly averaging (Newton-Raphson),
        but this is more accurate with less iterations for very small numbers as well as a few normal-sized numbers
        (e.g. 124).
    </span>
    <script>
        function nearestPerfectSquare(x) {
            var value = Math.pow(Math.round(Math.sqrt(x)), 2);
            if (value == 0) value = 1
            return {
                value: value,
                squareRoot: value ^ 0.5 //would be done with a table lookup in actual use but to save on memory (this is a browser so I can't hardcode values into storage) it's generated like this
            }
        }
        function solve() {
            let iterations = document.querySelector('.iterations').value;
            iterations == '' ? iterations = 2048 : null;
            let decimals = document.querySelector('.decimals').value;
            decimals == '' ? decimals = 10 : null;

            let factor = 10 ** decimals
            var x = Number(document.querySelector('.x').value) * factor

            var v = x / factor
            let mStart = performance.now()
            let msqrt = Math.sqrt(v)
            let mEnd = performance.now()

            let start = performance.now()
            let nps = nearestPerfectSquare(x).squareRoot;
            let a = (x - nps * nps) / nps
            let xp1 = (x % 1)
            let x2 = x * 2
            let iterationReq = 0

            var lv = 0
            if (iterations != 2048) {
                for (i = 1; i < iterations; i++) {
                    a = ((x2 / ((a * 0.5) + (xp1 / a))) + a) * 0.5
                }
            } else {
                for (i = 1; i < iterations; i++) {
                    a = ((x2 / ((a * 0.5) + (xp1 / a))) + a) * 0.5
                    lv == a && iterationReq == 0 ? iterationReq = i : lv = a;
                }
            }
            let sqrt = Math.abs(((a * 0.5) + (xp1 / a)) / (10 ** (decimals * 0.5)))
            iterationReq == 0 ? (sqrt == msqrt ? iterationReq = iterations : iterationReq = '?') : null;

            let end = performance.now()



            document.querySelector('.res').innerHTML = `This method:  ${sqrt}**<br>
            Math.sqrt(x): ${msqrt}<br>
            Difference: ${msqrt - sqrt}<br>
            Math.sqrt(x) squared: ${msqrt ** 2}<br>
            This method squared: ${sqrt ** 2}<br>
            Time for this method (ms): ${(end - start)}<br>
            Time for Math.sqrt (ms): ${mEnd - mStart}<br>
            Iterations until error = 0: ${iterationReq}<br>`
        }



        //other stuff:
        Array.from(document.querySelectorAll('input')).forEach(function (i, v) {
            i.style.width = (i.offsetWidth * 1.5) + 'px'
        })
    </script>
</body>

</html>